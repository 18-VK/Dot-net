# Scenario (Real app)
Expense Tracker

- Load transactions from database
- Show them in DataGrid
- Refresh data
- Delete selected row
- No code-behind logic

1ï¸âƒ£ MODEL (Database entity)
Represents DB table

ğŸ“ Models/Transaction.cs

public class Transaction
{
    public int Id { get; set; }
    public DateTime Date { get; set; }
    public string Category { get; set; }
    public decimal Amount { get; set; }
    public string Type { get; set; } // Income / Expense
}

âœ” No INotifyPropertyChanged
âœ” No UI logic
âœ” Pure data

2ï¸âƒ£ DATA ACCESS (Repository / Service)
This simulates real DB querying

(you can replace with EF Core later)

ğŸ“ Services/ITransactionService.cs

public interface ITransactionService
{
    List<Transaction> GetAll();
    void Delete(int id);
}


ğŸ“ Services/TransactionService.cs

public class TransactionService : ITransactionService
{
    private readonly List<Transaction> _db = new()
    {
        new Transaction { Id=1, Date=DateTime.Now, Category="Food", Amount=200, Type="Expense" },
        new Transaction { Id=2, Date=DateTime.Now, Category="Salary", Amount=50000, Type="Income" }
    };

    public List<Transaction> GetAll()
    {
        // Simulates DB query
        return _db.ToList();
    }

    public void Delete(int id)
    {
        var item = _db.FirstOrDefault(x => x.Id == id);
        if (item != null)
            _db.Remove(item);
    }
}

âœ” DB logic isolated
âœ” Replaceable with EF / Dapper later

3ï¸âƒ£ VIEWMODEL (UI Brain)

ğŸ“ ViewModels/TransactionViewModel.cs

public class TransactionViewModel : INotifyPropertyChanged
{
    private readonly ITransactionService _service;

    public ObservableCollection<Transaction> Transactions { get; }

    private Transaction _selectedTransaction;
    public Transaction SelectedTransaction
    {
        get => _selectedTransaction;
        set
        {
            _selectedTransaction = value;
            OnPropertyChanged();
        }
    }

    public ICommand LoadCommand { get; }
    public ICommand DeleteCommand { get; }

    public TransactionViewModel()
    {
        _service = new TransactionService();
        Transactions = new ObservableCollection<Transaction>();

        LoadCommand = new RelayCommand(Load);
        DeleteCommand = new RelayCommand(Delete, CanDelete);

        Load(); // initial load
    }

    private void Load()
    {
        Transactions.Clear();
        foreach (var item in _service.GetAll())
            Transactions.Add(item);
    }

    private bool CanDelete()
        => SelectedTransaction != null;

    private void Delete()
    {
        _service.Delete(SelectedTransaction.Id);
        Transactions.Remove(SelectedTransaction);
    }

    public event PropertyChangedEventHandler PropertyChanged;
    private void OnPropertyChanged([CallerMemberName] string prop = null)
        => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(prop));
}

ğŸ”¥ Why this is REAL MVVM

âœ” Uses ObservableCollection
âœ” Uses SelectedItem
âœ” Uses ICommand
âœ” Calls DB via service
âœ” No UI reference

4ï¸âƒ£ RelayCommand (Required)

ğŸ“ Commands/RelayCommand.cs

public class RelayCommand : ICommand
{
    private readonly Action _execute;
    private readonly Func<bool> _canExecute;

    public RelayCommand(Action execute, Func<bool> canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
        => _canExecute == null || _canExecute();

    public void Execute(object parameter)
        => _execute();

    public event EventHandler CanExecuteChanged
    {
        add => CommandManager.RequerySuggested += value;
        remove => CommandManager.RequerySuggested -= value;
    }
}

5ï¸âƒ£ VIEW (DataGrid UI)

ğŸ“ Views/MainWindow.xaml

<Window x:Class="ExpenseApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Transactions"
        Height="350"
        Width="600">

    <Window.DataContext>
        <local:TransactionViewModel/>
    </Window.DataContext>

    <DockPanel Margin="10">

        <StackPanel DockPanel.Dock="Top"
                    Orientation="Horizontal"
                    Margin="0,0,0,10">

            <Button Content="Refresh"
                    Command="{Binding LoadCommand}"
                    Width="100"/>

            <Button Content="Delete"
                    Command="{Binding DeleteCommand}"
                    Width="100"
                    Margin="10,0,0,0"/>
        </StackPanel>

        <DataGrid ItemsSource="{Binding Transactions}"
                  SelectedItem="{Binding SelectedTransaction}"
                  AutoGenerateColumns="False"
                  IsReadOnly="True">

            <DataGrid.Columns>
                <DataGridTextColumn Header="Date"
                                    Binding="{Binding Date}" />

                <DataGridTextColumn Header="Category"
                                    Binding="{Binding Category}" />

                <DataGridTextColumn Header="Amount"
                                    Binding="{Binding Amount}" />

                <DataGridTextColumn Header="Type"
                                    Binding="{Binding Type}" />
            </DataGrid.Columns>

        </DataGrid>

    </DockPanel>
</Window>


6ï¸âƒ£ Flow (How data moves)
Database
   â†“
Service (Query)
   â†“
ViewModel (ObservableCollection)
   â†“
DataGrid (Binding)

example : 
ğŸ” Delete:

Button â†’ Command â†’ ViewModel â†’ Service â†’ UI updates automatically


7ï¸âƒ£ Why this design is JOB-READY â­

âœ” Easy to add paging / filtering
âœ” Easy to unit test ViewModel
âœ” No code-behind logic
âœ” DB logic isolated
âœ” Replaceable UI (DataGrid â†’ ListView)

