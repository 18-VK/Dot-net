# MVVM in WPF 

MVVM = Model ‚Äì View ‚Äì ViewModel
It is the core architectural pattern used in WPF to build clean, testable, maintainable UI applications.

This is the core principle behind clean WPF applications. If you understand this well, bindings, commands, 
converters, and templates all make sense.

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      Binding / Command      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  View   ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  ‚îÇ ViewModel   ‚îÇ
‚îÇ (XAML)  ‚îÇ  ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ (Logic)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     INotifyPropertyChanged  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚ñº
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   ‚îÇ  Model  ‚îÇ
                   ‚îÇ (Data)  ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

- View never talks to Model directly
- ViewModel never talks to View directly (using INotifyPropertyChanged)

Why MVVM exists (the problem it solves)
Without MVVM:

- UI logic goes into code-behind
- Hard to test
- UI tightly coupled to business logic
- Difficult to maintain as app grows
- MVVM solves this by separating responsibilities.

>> Model 
Model ‚Äî ‚ÄúWhat the app KNOWS‚Äù

Responsibility

- Business data
- Domain rules
- Validation (business level)
- DB / API contracts (often via services)

What belongs here

- Entities
- DTOs
- Business calculations

What does NOT belong

‚ùå UI state
‚ùå Commands
‚ùå PropertyChanged

example : 
public class Order
{
    public int Id { get; set; }
    public decimal Amount { get; set; }
    public OrderStatus Status { get; set; }
}


>> View ‚Äî ‚ÄúWhat the user SEES‚Äù
Responsibility

- Layout (XAML)
- Styling & templates
- Bindings
- No logic

What belongs here

- XAML only
- Converters
- DataTemplates
- Visual states

What does NOT belong

‚ùå Business logic
‚ùå Database calls
‚ùå if/else decisions
‚ùå Click handlers (mostly)

Example

<TextBox Text="{Binding Amount, Mode=TwoWay}" />
<Button Command="{Binding SaveCommand}" />

>> ViewModel ‚Äî ‚ÄúHow the screen BEHAVES‚Äù üß†
Responsibility

- UI state
- Commands
- Data shaping for UI
- Communication with Model / Services

What belongs here

- Properties for binding
- Commands (ICommand)
- Validation (UI-level)
- Computed properties

What does NOT belong

‚ùå UI elements (Button, TextBox)
‚ùå XAML
‚ùå Colors, fonts

Example
public class OrderViewModel : INotifyPropertyChanged
{
    public Order CurrentOrder { get; }

    public decimal Amount
    {
        get => CurrentOrder.Amount;
        set
        {
            CurrentOrder.Amount = value;
            OnPropertyChanged();
            OnPropertyChanged(nameof(CanSave));
        }
    }

    public bool CanSave => Amount > 0;

    public ICommand SaveCommand { get; }
}

## Common MVVM separation mistakes ‚ùå

‚ùå Logic in View
<Button Click="if(User.IsAdmin) Save()"/>

‚ùå UI in ViewModel
MessageBox.Show("Saved!");

‚ùå Business logic in Converter
Converter checks user role from DB

## ViewModel vs Model (interview favorite)

| Aspect              | Model         | ViewModel   |
| ------------------- | ------------- | ----------- |
| Purpose             | Business data | UI behavior |
| Depends on WPF      | ‚ùå             | ‚úî           |
| Has PropertyChanged | ‚ùå             | ‚úî           |
| Used in UI          | Indirect      | Direct      |
| Testable            | ‚úî             | ‚úî           |

## Interview-ready summary ‚≠ê

Model holds data, View displays it, ViewModel controls behavior.
They communicate via bindings and commands, not references.

# What is Data Binding?

Data binding connects UI elements (XAML) to data (ViewModel / model / static objects) so the UI updates 
automatically and your code-behind stays minimal ‚Äî the core of MVVM.

## When & Where to use data binding (real-app guidance)

- Use binding for all UI ‚Üî data interactions except trivial UI-only behaviors (focus, animations).
- Use TwoWay binding for form inputs (TextBox, CheckBox, ComboBox) where user edits data.
- Use OneWay binding when view displays data from VM but VM doesn‚Äôt expect UI to change it (labels, read-only 
fields).
- Use OneTime for values that won‚Äôt change (app title).
- Use Bindings + Commands instead of event handlers for buttons/actions (MVVM).
- Bind collections (ObservableCollection<T>) to ItemsControl/ListBox/DataGrid for lists/grids.
- Use CollectionViewSource / ICollectionView for sorting, grouping, paging, filter logic.
- Use binding-based validation (IDataErrorInfo / INotifyDataErrorInfo / ValidationRule) for user input.
- Use converters (IValueConverter / IMultiValueConverter) for UI-specific formatting/transformations.
- Avoid binding UI-sensitive large datasets directly without virtualization.

## Binding modes quick cheat

- TwoWay ‚Äî input controls (TextBox.Text, SelectedItem)
- OneWay ‚Äî read-only UI
- OneTime ‚Äî static values (theme colors that won't change)
- OneWayToSource ‚Äî push-only (rarely used ‚Äî e.g., capturing control value into VM, not updating UI)

## Basic pieces you need in real apps

- ViewModel implementing INotifyPropertyChanged
- ObservableCollection<T> for lists, so UI updates on add/remove
- Commands (ICommand) for actions (login/save/delete)
- DataContext set on window/usercontrol (ViewModel-first or View-first)
- XAML bindings referencing ViewModel properties/commands

## Binding modes in WPF

In WPF a Binding's Mode controls how data flows between the source (usually your ViewModel) and the target (a 
DependencyProperty on a UI element).

Type of Bindings  : 
----------------
- OneWay ‚Äî source ‚Üí target. Target updates when source changes; target changes do not update source.
Use for read-only UI that reflects model changes.

- TwoWay ‚Äî source ‚áÑ target. Both update each other.
Use for form inputs and interactive controls.

- OneTime ‚Äî source ‚Üí target once (when the binding is created). After that no updates.
Use for static data or values that won't change (better performance).

- OneWayToSource ‚Äî target ‚Üí source only. Rare; used when UI pushes values to model but model shouldn't push 
back.

Default mode depends on the dependency property‚Äôs metadata. Many properties default to OneWay, but some (e.g. 
TextBox.Text) default to TwoWay. Always specify Mode= when you need a specific behavior.

## DataContext in WPF ‚Äî explained simply (with clear examples)

DataContext is the object that WPF bindings look at by default to resolve binding paths.

In one line:
DataContext = ‚ÄúFrom where should this UI get its data?‚Äù

<TextBox Text="{Binding Name}" />
WPF internally reads it as:
‚ÄúGet property Name from the current DataContext.‚Äù

If DataContext is:
new PersonViewModel { Name = "Aman" }

‚û° The TextBox shows Aman

Note : Full example, explained below 

## Practical use-cases + tips

1. TwoWay

When: Forms, text inputs, checkboxes, editable controls where the user changes values that must flow into the 
ViewModel.

Important details:

- Ensure the source property raises INotifyPropertyChanged so UI reflects external updates.
- For TextBox.Text, default UpdateSourceTrigger is LostFocus (so source updates on focus loss). If you want 
live updates while typing, set UpdateSourceTrigger=PropertyChanged.
- Example: editing user profile fields, live validation if desired.

2. OneWay

When: Display-only elements that should reflect model changes (status messages, read-only labels that update).

Why: Simpler, safe (user cannot change the data), often slightly cheaper than TwoWay.

Example: TextBlock showing CurrentUser.Status.

3. OneTime

When: Data that is static after creation ‚Äî e.g., configuration values, captions loaded once, or items that 
won't change in the view‚Äôs lifetime.

Why: Slight performance advantage because no listeners are kept for changes.

Example: App title, initial user greeting that never changes while view is open.

4. OneWayToSource

When: UI supplies data to the model but the model shouldn't push changes back ‚Äî e.g., a transient control that 
sends a value to service but model changes come from elsewhere and shouldn‚Äôt overwrite the control.

Example: A "temporary" slider that only sends feedback to a hardware API represented in the ViewModel.

## UpdateSourceTrigger ‚Äî important companion to Mode

- PropertyChanged ‚Äî update source as soon as the target property changes (e.g., every keystroke).
- LostFocus ‚Äî update when the control loses focus (default for TextBox.Text).
- Explicit ‚Äî only update when you call BindingExpression.UpdateSource().

Use PropertyChanged for immediate feedback (live search), and LostFocus for less chatty updates (forms where 
you want to validate on submit).

Example:

<TextBox Text="{Binding Name, Mode=TwoWay, UpdateSourceTrigger=LostFocus}" />

## Common pitfalls

- No INotifyPropertyChanged? UI will not reflect changes from ViewModel for OneWay/TwoWay. Implement it for 
  source properties.
- Wrong Mode assumption. Don‚Äôt assume TextBox.Text will always be TwoWay on every control/property ‚Äî check the 
  property metadata or explicitly set Mode.
- Performance: TwoWay with UpdateSourceTrigger=PropertyChanged can be chatty (many updates). Use throttling or 
  validation if required.
- Templates: Binding inside ControlTemplate may require TemplatedParent or RelativeSource binding; modes still 
  apply the same.

## Example how to setup things 

1. ViewModel
Create file: MainViewModel.cs or name any thing 

using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace BindingModesDemo
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private string _name;
        private string _status;
        private double _rating;

        public string Name
        {
            get => _name;
            set
            {
                if (_name == value) return;
                _name = value;
                OnPropertyChanged();
                Status = $"Name changed to: {_name}";
            }
        }

        public string Status
        {
            get => _status;
            set
            {
                if (_status == value) return;
                _status = value;
                OnPropertyChanged();
            }
        }

        public double Rating
        {
            get => _rating;
            set
            {
                if (_rating == value) return;
                _rating = value;
                OnPropertyChanged(); 
                // or can call from here  PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof
                (Rating)));
            }
        }

        public MainViewModel()
        {
            Name = "Aman";
            Status = "Waiting for input...";
            Rating = 3;
        }

        public event PropertyChangedEventHandler PropertyChanged;
        private void OnPropertyChanged([CallerMemberName] string propName = null)
            => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propName)); // calling for each 
            property 
    }
}

2. MainWindow XAML (UI) sample 

<Window x:Class="BindingModesDemo.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Binding Modes Demo"
        Height="350"
        Width="420">

    <StackPanel Margin="15">

        <TextBlock Text="TwoWay Binding (TextBox ‚Üí ViewModel)"
                   FontWeight="Bold"/>

        <!-- TwoWay -->
        <TextBox Text="{Binding Name,
                        Mode=TwoWay,
                        UpdateSourceTrigger=PropertyChanged}"
                 Margin="0,5,0,10"/>


        <TextBlock Text="OneWay Binding (ViewModel ‚Üí UI)"
                   FontWeight="Bold"/>

        <!-- OneWay -->
        <TextBlock Text="{Binding Status, Mode=OneWay}"
                   Foreground="Green"
                   Margin="0,5,0,10"/>


        <TextBlock Text="OneTime Binding (Loaded once)"
                   FontWeight="Bold"/>

        <!-- OneTime -->
        <Label Content="{Binding Name, Mode=OneTime}"
               Background="#EEE"
               Margin="0,5,0,10"/>


        <TextBlock Text="OneWayToSource (UI ‚Üí ViewModel)"
                   FontWeight="Bold"/>

        <!-- OneWayToSource -->
        <Slider Minimum="0"
                Maximum="5"
                TickFrequency="1"
                IsSnapToTickEnabled="True"
                Value="{Binding Rating,
                        Mode=OneWayToSource,
                        UpdateSourceTrigger=PropertyChanged}"/>

        <TextBlock Text="{Binding Rating,
                          StringFormat=Rating sent to VM: {0}}"
                   Margin="0,5,0,0"/>

    </StackPanel>
</Window>

3. Code-behind (set DataContext)

namespace BindingModesDemo
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            DataContext = new MainViewModel();
        }
    }
}

Extra : 

>> What is [CallerMemberName]?

[CallerMemberName] is an attribute that automatically supplies the name of the calling member (property / 
method) to a method parameter at compile time.

In simple words:
It saves you from writing property names as strings.

üîπ Why it exists (problem it solves)

‚ùå Old way (error-prone):

PropertyChanged?.Invoke(this,
    new PropertyChangedEventArgs("Name")); // typo risk!

>> What is nameof?

nameof returns the string name of a variable, property, class, or method at compile time.

nameof(Name)        // "Name"
nameof(PersonViewModel) // "PersonViewModel"


## ElementName Binding and RelativeSource Bindings

1. What is ElementName binding?
ElementName binding lets one control bind to another named control in the same XAML scope.

‚ÄúBind to that control over there by its name.‚Äù

<TextBox x:Name="txtUser" Width="200"/>

<TextBlock Text="{Binding Text, ElementName=txtUser}" />

What happens?

- TextBlock shows whatever is typed into TextBox
- No ViewModel involved

>> Common use cases
‚úÖ 1. UI-to-UI binding (without ViewModel)
<Slider x:Name="slider" Minimum="0" Maximum="100"/>

<TextBlock Text="{Binding Value, ElementName=slider}" />

‚úÖ 2. Bind Width / Height between controls
<TextBox x:Name="txtSearch" Width="250"/>

<ListBox Width="{Binding ActualWidth, ElementName=txtSearch}" />

‚úÖ 3. Toggle visibility based on CheckBox
<CheckBox x:Name="chkShow" Content="Show details"/>

<TextBlock Text="Details"
           Visibility="{Binding IsChecked,
                        ElementName=chkShow,
                        Converter={StaticResource BoolToVisibility}}" />

>> Limitations of ElementName ‚ùå

Works only in the same namescope

‚ùå Does NOT work well inside:
DataTemplate
ControlTemplate
‚ùå Tightly couples UI elements

2. What is RelativeSource?

RelativeSource binds to a related element in the Logical or Visual Tree, instead of a named element.

‚ÄúBind to my parent / ancestor / self / templated parent.‚Äù

RelativeSource modes (must know)
| Mode            | Meaning                     |
| --------------- | --------------------------- |
| Self            | Bind to the same control    |
| FindAncestor    | Bind to parent / ancestor   |
| TemplatedParent | Used inside ControlTemplate |
| PreviousData    | Used in ItemsControl (rare) |

>> Examples :

RelativeSource ‚Äì Self

Example: bind Width to Height
<Button Content="Square"
        Width="{Binding Height,
                RelativeSource={RelativeSource Self}}"
        Height="50"/>


RelativeSource ‚Äì TemplatedParent üé®

Example : Used inside ControlTemplate
<ControlTemplate TargetType="Button">
    <Border Background="{Binding Background,
                         RelativeSource={RelativeSource TemplatedParent}}">
        <ContentPresenter/>
    </Border>
</ControlTemplate>


‚ùå ElementName does NOT work here
‚úî TemplatedParent is correct

### RelativeSource ‚Äì FindAncestor (VERY IMPORTANT ‚≠ê)

<StackPanel DataContext="{Binding User}">
    <TextBlock Text="{Binding Name}" />

    <!-- Need parent VM -->
    <Button Content="Delete"
            Command="{Binding DataContext.DeleteUserCommand,
                      RelativeSource={RelativeSource AncestorType=Window}}" />
</StackPanel>

‚úî Used when DataContext changes in child scopes

### RelativeSource ‚Äì DataTemplate example (ItemsControl)
<ListBox ItemsSource="{Binding Users}">
    <ListBox.ItemTemplate>
        <DataTemplate>
            <Button Content="Delete"
                    Command="{Binding DataContext.DeleteUserCommand,
                              RelativeSource={RelativeSource AncestorType=ListBox}}" />
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>

Each item‚Äôs DataContext = User,
but command lives in MainViewModel

### explaination for both : 

Problem: Command binding fails inside templates ‚ùå
Scenario : 

- You have a ListBox of users
- Each row has a Delete button
- Command lives in MainViewModel
- Item template DataContext = User, not MainViewModel

‚ùå Wrong approach (this FAILS)
<Button Content="Delete"
        Command="{Binding DeleteUserCommand}" />

Why it fails?

- Inside DataTemplate
- DataContext = User
- DeleteUserCommand exists in MainViewModel, not in User

‚úÖ Correct Solution: FindAncestor ‚≠ê
Bind command from ancestor‚Äôs DataContext
<Button Content="Delete"
        Command="{Binding DataContext.DeleteUserCommand,
                  RelativeSource={RelativeSource AncestorType=ListBox}}"
        CommandParameter="{Binding}" />

üîç What happens step-by-step

- FindAncestor walks up the Logical Tree
- Finds nearest ListBox
- Reads its DataContext ‚Üí MainViewModel
- Executes DeleteUserCommand
- CommandParameter="{Binding}" passes current User

## Converter (IValueConverter)

IValueConverter is used when the source value and target value types don‚Äôt match, or when the UI needs a 
transformed version of the ViewModel data.

In simple words:
Converter = ‚Äútranslate ViewModel data into UI-friendly data (and back)‚Äù

>> Interface definition :

public interface IValueConverter
{
    object Convert(object value, Type targetType,
                   object parameter, CultureInfo culture);

    object ConvertBack(object value, Type targetType,
                       object parameter, CultureInfo culture);
}

- Convert ‚Üí ViewModel ‚Üí UI
- ConvertBack ‚Üí UI ‚Üí ViewModel (TwoWay binding)

### Most common example: bool ‚Üí Visibility ‚≠ê
Step 1: Converter

public class BoolToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType,
                          object parameter, CultureInfo culture)
    {
        bool isVisible = value is bool b && b;
        return isVisible ? Visibility.Visible : Visibility.Collapsed;
    }

    public object ConvertBack(object value, Type targetType,
                              object parameter, CultureInfo culture)
    {
        return (Visibility)value == Visibility.Visible;
    }
}

Step 2: Register in XAML
<Window.Resources>
    <local:BoolToVisibilityConverter x:Key="BoolToVisibility"/>
</Window.Resources>

Step 3: Use in Binding
<TextBlock Text="Admin Panel"
           Visibility="{Binding IsAdmin,
                        Converter={StaticResource BoolToVisibility}}" />

### Converter with Parameter (advanced but useful)
<TextBlock Visibility="{Binding IsLoggedIn,
                        Converter={StaticResource BoolToVisibility},
                        ConverterParameter=Invert}" />

bool invert = parameter?.ToString() == "Invert";
return invert ? Visibility.Collapsed : Visibility.Visible;

### Real-world examples (MUST KNOW)

Example 1: Status enum ‚Üí Color
public enum OrderStatus { New, Processing, Completed }

public class StatusToBrushConverter : IValueConverter
{
    public object Convert(object value, Type t, object p, CultureInfo c)
    {
        return (OrderStatus)value switch
        {
            OrderStatus.New => Brushes.Blue,
            OrderStatus.Processing => Brushes.Orange,
            OrderStatus.Completed => Brushes.Green,
            _ => Brushes.Gray
        };
    }

    public object ConvertBack(...) => Binding.DoNothing;
}

<TextBlock Text="{Binding Status}"
           Foreground="{Binding Status,
                        Converter={StaticResource StatusToBrush}}" />

### When to use ConvertBack?
| Scenario           | ConvertBack |
| ------------------ | ----------- |
| OneWay binding     | ‚ùå           |
| TwoWay binding     | ‚úî           |
| Read-only UI       | ‚ùå           |
| User input editing | ‚úî           |

### Common mistakes ‚ùå

‚ùå Doing DB / API calls in converters
‚ùå Changing ViewModel state
‚ùå Throwing exceptions
‚ùå Forgetting Binding.DoNothing in ConvertBack

