# Style Tag(XAML)
A Style is a way to define properties once and reuse them for many controls.

Think of it like:
CSS class for WPF controls
Instead of writing the same properties again and again, you put them in a Style.

Video linlk : https://youtu.be/2HP1Ig5HEgs
Can go through this after basic understanding of style 

Why use Style

âœ” Clean XAML
âœ” Reusable UI
âœ” Consistent look
âœ” Easy maintenance

## A Dependency Property (DP) is:

A property defined by WPF controls
Supports styling, animation, triggers, binding

Examples:

- IsEnabled
- IsMouseOver
- IsFocused
- IsSelected
- Visibility
- Validation.HasError

These are built into the control.

>> Without Style

<Button Content="Save"
        Width="100"
        Height="30"
        Background="Blue"
        Foreground="White"
        FontWeight="Bold"
        Margin="5"/>

>> With Style  

<Window.Resources>
    <Style x:Key="PrimaryButtonStyle" TargetType="Button">
        <Setter Property="Width" Value="100"/>
        <Setter Property="Height" Value="30"/>
        <Setter Property="Background" Value="Blue"/>
        <Setter Property="Foreground" Value="White"/>
        <Setter Property="FontWeight" Value="Bold"/>
        <Setter Property="Margin" Value="5"/>
    </Style>
</Window.Resources>

<Button Content="Save" Style="{StaticResource PrimaryButtonStyle}"/>
<Button Content="Update" Style="{StaticResource PrimaryButtonStyle}"/>

>>  Useful properties

| Property     | Use case              |
| ------------ | --------------------- |
| `TargetType` | Which control         |
| `Setter`     | Set property value    |
| `BasedOn`    | Inherit another style |
| `Triggers`   | Change UI on state    |
| `x:Key`      | Named style           |

>> Implicit Style (No Key)

Applies to ALL Buttons automatically
<Window.Resources>
    <Style TargetType="Button">
        <Setter Property="Margin" Value="5"/>
        <Setter Property="Height" Value="30"/>
    </Style>
</Window.Resources>

âœ” Every Button gets this style
âœ” No need to set Style=...

>> Style with BasedOn (Reuse Another Style)

<Style x:Key="DangerButtonStyle"
       TargetType="Button"
       BasedOn="{StaticResource PrimaryButtonStyle}">
    <Setter Property="Background" Value="Red"/>
</Style>
Inherited from 'PrimaryButtonStyle'

âœ” Inherit properties
âœ” Override only whatâ€™s different

>> Style with Triggers (VERY IMPORTANT â­)

Change UI based on state
<Style x:Key="HoverButtonStyle" TargetType="Button">
    <Setter Property="Background" Value="LightGray"/>

    <Style.Triggers>
        <Trigger Property="IsMouseOver" Value="True">
            <Setter Property="Background" Value="DarkGray"/>
        </Trigger>

        <Trigger Property="IsEnabled" Value="False">
            <Setter Property="Opacity" Value="0.5"/>
        </Trigger>
    </Style.Triggers>
</Style>
âœ” Hover effect
âœ” Disabled look

Common Trigger properties
| Property      | Meaning        |
| ------------- | -------------- |
| `IsMouseOver` | Hover          |
| `IsEnabled`   | Disabled state |
| `IsFocused`   | Keyboard focus |
| `IsSelected`  | Selected item  |

Note : It may not work, to get the solution go through the video link given above 

>> DataTrigger (Based on Data)

<Style TargetType="TextBlock">
    <Setter Property="Foreground" Value="Black"/>

    <Style.Triggers>
        <DataTrigger Binding="{Binding IsError}" Value="True">
            <Setter Property="Foreground" Value="Red"/>
        </DataTrigger>
    </Style.Triggers>
</Style>

âœ” UI reacts to data
âœ” Common in MVVM

>> Multi trigger 
A MultiTrigger:

- Executes setters only when ALL conditions are true
- Works with dependency properties (not bindings)
- Is used inside Style.Triggers or ControlTemplate.Triggers

<Style TargetType="Button">
    <Setter Property="Background" Value="Gray"/>

    <Style.Triggers>
        <MultiTrigger>
            <MultiTrigger.Conditions>
                <Condition Property="IsMouseOver" Value="True"/>
                <Condition Property="IsEnabled" Value="True"/>
            </MultiTrigger.Conditions>
            <Setter Property="Background" Value="Blue"/>
        </MultiTrigger>

        <Trigger Property="IsEnabled" Value="False">
            <Setter Property="Opacity" Value="0.5"/>
        </Trigger>
    </Style.Triggers>
</Style>

>> Style for ItemsControl ItemContainer (Important)

<ItemsControl.ItemContainerStyle>
    <Style TargetType="ContentPresenter">
        <Setter Property="Margin" Value="8"/>
    </Style>
</ItemsControl.ItemContainerStyle>

âœ” Controls spacing
âœ” Cleaner layouts

Note : TargetType="ContentPresenter", will explain below 

## Style vs ControlTemplate (Simple Difference)

| Style           | ControlTemplate   |
| --------------- | ----------------- |
| Sets properties | Redesigns control |
| Easy            | Advanced          |
| Most common     | Rarely needed     |

Start with Style, not Template.

Note : Go watch above video to get more understanding 

## Simple Summary (Remember This)

Style
- Reuse UI settings
- Uses Setter
- Uses Triggers for behavior
- Can be implicit or explicit

# Where can Styles live? Control.Resources, Window.Resources and Application.Resources

| Location                | Scope           |
| ----------------------- | --------------- |
| `Control.Resources`     | One control     |
| `Window.Resources`      | Whole window    |
| `Application.Resources` | Whole app       |
| Separate `.xaml` file   | Reusable themes |

## What are Resources in WPF?
Resources are reusable objects stored with a key, such as:
- Styles
- Brushes (colors)
- Templates
- Converters
- DataTemplates
- ControlTemplates

ğŸ‘‰ Instead of repeating XAML again and again, you define it once and reuse it.

## Resource Scope (Most Important Concept)
WPF resources work in a hierarchical scope:

Control â†’ Window â†’ Application â†’ System

A Control can access:

- Its own resources
- Parent Window resources
- Application resources

A Window can access:

- Its own resources
- Application resources

Application resources are available everywhere

## Control.Resources

- Inside any control (Button, Grid, StackPanel, TextBox, etc.)
- Available ONLY to that control and its children

âœ… Use When
- Style/template is used only inside a specific control
- You want local customization
- Avoid affecting other UI parts

Example: Control-level Style

<StackPanel>
    <StackPanel.Resources>
        <Style TargetType="Button">
            <Setter Property="Background" Value="LightBlue"/>
            <Setter Property="Margin" Value="5"/>
        </Style>
    </StackPanel.Resources>

    <Button Content="Save"/>
    <Button Content="Cancel"/>
</StackPanel>

âœ” Only buttons inside this StackPanel get the style
âŒ Buttons outside are unaffected

Example: Resource for Single Control

<Button Content="Login">
    <Button.Resources>
        <SolidColorBrush x:Key="BtnBrush" Color="Green"/>
    </Button.Resources>

    <Button.Background>
        {StaticResource BtnBrush}
    </Button.Background>
</Button>

## Window.Resources

- Inside a Window or UserControl
- Available to all controls inside that Window/UserControl

âœ… Use When

- Resource used multiple times in one window
- Page-specific styles
- Avoid global impact

Example: Window-Level Style

<Window x:Class="Demo.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">

    <Window.Resources>
        <Style TargetType="TextBox">
            <Setter Property="Margin" Value="10"/>
            <Setter Property="Width" Value="200"/>
        </Style>
    </Window.Resources>

    <StackPanel>
        <TextBox/>
        <TextBox/>
    </StackPanel>
</Window>

âœ” Applies to all TextBoxes in this window
âŒ Not applied in other windows

Example: Window-level Brush

<Window.Resources>
    <SolidColorBrush x:Key="PrimaryColor" Color="#007ACC"/>
</Window.Resources>

<Button Background="{StaticResource PrimaryColor}"
        Content="Submit"/>

## Application.Resources

- Inside App.xaml
- Available throughout the entire application

âœ… Use When

- Common styles
- Theme colors
- Converters
- Templates used everywhere

Example: Global Button Style

App.xaml

<Application.Resources>
    <Style TargetType="Button">
        <Setter Property="Padding" Value="10"/>
        <Setter Property="FontSize" Value="14"/>
    </Style>
</Application.Resources>


âœ” All buttons in all windows get this style
âœ” Centralized UI management

Example: Global Colors

<Application.Resources>
    <SolidColorBrush x:Key="PrimaryBrush" Color="#2196F3"/>
    <SolidColorBrush x:Key="DangerBrush" Color="Red"/>
</Application.Resources>

<Button Background="{StaticResource PrimaryBrush}" />
<Button Background="{StaticResource DangerBrush}" />

## Note : How Resource Lookup Works (IMPORTANT)

When WPF looks for a resource:

- Current control
- Parent control(s)
- Window
- Application
- System resources

ğŸ‘‰ Closest resource wins

Example: Resource Override

<Application.Resources>
    <SolidColorBrush x:Key="ThemeColor" Color="Blue"/>
</Application.Resources>

<Window.Resources>
    <SolidColorBrush x:Key="ThemeColor" Color="Green"/>
</Window.Resources>

<Button Background="{StaticResource ThemeColor}"/>

âœ” Button background = Green

## StaticResource vs DynamicResource (Quick Tip)

| StaticResource           | DynamicResource       |
| ------------------------ | --------------------- |
| Loaded once              | Updates at runtime    |
| Faster                   | Slightly slower       |
| Cannot change after load | Supports theme change |

e.g : 
Background="{DynamicResource PrimaryBrush}"

Use DynamicResource for themes / runtime changes.
Use DynamicResource for:

- Light/Dark theme
- Runtime color change

## Best Practices (Real Projects)

âœ” Put global styles & colors in App.xaml
âœ” Use Window.Resources for page-specific UI
âœ” Use Control.Resources to override styles locally
âœ” Use separate ResourceDictionary files for large apps - Explained below

# ContentTemplate and ContentPresenter

## What is ControlTemplate?

A ControlTemplate defines the visual structure of a control.
Think of it as:

â€œHow the control looks internallyâ€
Examples:

Button â†’ Border + content
TextBox â†’ Border + ScrollViewer
CheckBox â†’ Box + text

âš ï¸ ControlTemplate does NOT define behavior, only appearance.

## Why ControlTemplate is Needed?

Default WPF controls already have templates, but:

- You want custom look
- You want modern UI
- You want rounded buttons
- You want icons inside buttons

ğŸ‘‰ You replace the ControlTemplate.

## What is ContentPresenter?

ContentPresenter is the placeholder that displays the controlâ€™s content.
Whatever is set in Content property appears inside ContentPresenter.

Relationship Between ControlTemplate & ContentPresenter : 
ğŸ”‘ Golden Rule

ControlTemplate defines the structure
ContentPresenter shows the content inside that structure

ğŸ‘‰ Without ContentPresenter, the controlâ€™s content is LOST.

Simple Example: Custom Button
-----------------------------
ğŸ”¹ XAML (Style with ControlTemplate)

<Window.Resources>
    <Style TargetType="Button">
        <Setter Property="Background" Value="#007ACC"/>
        <Setter Property="Foreground" Value="White"/>
        <Setter Property="Padding" Value="10"/>

        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="Button">

                    <Border Background="{TemplateBinding Background}"
                            Padding="{TemplateBinding Padding}"
                            CornerRadius="6">

                        <!-- Content goes here -->
                        <ContentPresenter
                            HorizontalAlignment="Center"
                            VerticalAlignment="Center"/>

                    </Border>

                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</Window.Resources>

Usage
-------
<Button Content="Save"/>

or

<Button>
    <StackPanel Orientation="Horizontal">
        <TextBlock Text="ğŸ’¾"/>
        <TextBlock Text=" Save"/>
    </StackPanel>
</Button>


âœ” Both work because of ContentPresenter

What Happens Internally? : 

Button
 â””â”€â”€ ControlTemplate
      â””â”€â”€ Border
           â””â”€â”€ ContentPresenter
                â””â”€â”€ Button.Content

Example : Target control with name 

<Window.Resources>
    <ControlTemplate x:Key="SpecificControlTemplate" TargetType="{x:Type Button}">
        <!-- Visual structure of the template (e.g., a Grid, Border, ContentPresenter, etc.) -->
        <Border Background="Orange" BorderBrush="Black" BorderThickness="1">
            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
        </Border>
    </ControlTemplate>
</Window.Resources>

usage : 

<Button x:Name="MySpecificButton" 
        Content="Click Me" 
        Template="{StaticResource SpecificControlTemplate}" />

<!-- A different button that does not use this template -->
<Button Content="Normal Button" />

## What if ContentPresenter is Missing?

<ControlTemplate TargetType="Button">
    <Border Background="Red">
        <TextBlock Text="Fixed Text"/>
    </Border>
</ControlTemplate>


ğŸš« Button.Content ignored
ğŸš« All buttons show same text
ğŸš« Not reusable

## Note : Very Important Warning (Interview Favorite)

Putting a ControlTemplate without x:Key in App.xaml overrides the default control template globally.

This can:
âŒ Break third-party controls
âŒ Remove accessibility features
âŒ Break keyboard focus visuals


## TemplateBinding Explained (IMPORTANT)
TemplateBinding is a lightweight binding used inside a ControlTemplate to connect:
Controlâ€™s public properties â†’ template visuals

In simple words:
â€œUse the value from the control that is using this template.â€

Background="{TemplateBinding Background}"


âœ” Binds template to control property
âœ” Faster than normal Binding
âœ” Used only inside ControlTemplate

example : 
<Style TargetType="Button">
    <Setter Property="Background" Value="#1976D2"/>
    <Setter Property="Padding" Value="10"/>

    <Setter Property="Template">
        <Setter.Value>
            <ControlTemplate TargetType="Button">
                <Border
                    Background="{TemplateBinding Background}"
                    Padding="{TemplateBinding Padding}"
                    CornerRadius="6">

                    <ContentPresenter
                        HorizontalAlignment="Center"
                        VerticalAlignment="Center"/>
                </Border>
            </ControlTemplate>
        </Setter.Value>
    </Setter>
</Style>


## ControlTemplate with Triggers (Real-World Use)

<ControlTemplate TargetType="Button">
    <Border x:Name="border"
            Background="{TemplateBinding Background}"
            CornerRadius="6">

        <ContentPresenter HorizontalAlignment="Center"
                          VerticalAlignment="Center"/>

    </Border>

    <ControlTemplate.Triggers>
        <Trigger Property="IsMouseOver" Value="True">
            <Setter TargetName="border"
                    Property="Background"
                    Value="#005A9E"/>
        </Trigger>

        <Trigger Property="IsPressed" Value="True">
            <Setter TargetName="border"
                    Property="Background"
                    Value="#003F6B"/>
        </Trigger>
    </ControlTemplate.Triggers>
</ControlTemplate>

âœ” Hover effect
âœ” Pressed effect
âœ” Professional UI

## ControlTemplate vs DataTemplate (Quick Compare)

| ControlTemplate          | DataTemplate                  |
| ------------------------ | ----------------------------- |
| Changes control look     | Changes data display          |
| Used for Button, TextBox | Used in ListBox, ItemsControl |
| Uses ContentPresenter    | Uses bindings                 |

## When to Use ControlTemplate?

| Scenario                  | Use |
| ------------------------- | --- |
| Change control appearance | âœ”   |
| Re-skin Button/TextBox    | âœ”   |
| Custom UI theme           | âœ”   |
| Change data layout        | âŒ  |

## Style VS ContentTemplate 

What is a Style?

A Style is used to:

- Set properties
- Reuse appearance logic
- Add Triggers
- Apply consistent UI

It does NOT change the internal structure of a control.

What is a ControlTemplate?

A ControlTemplate defines:

- Visual tree
- Layout (Border, Grid, Shapes)
- Where content appears

It completely replaces the default UI of the control.

Real-World Analogy

| Concept         | Analogy                       |
| --------------- | ----------------------------- |
| Style           | Changing paint, font, padding |
| ControlTemplate | Rebuilding the house          |


Style vs ControlTemplate â€” Side-by-Side : 

| Feature               | Style | ControlTemplate |
| --------------------- | ----- | --------------- |
| Changes colors        | âœ”     | âœ”               |
| Changes layout        | âŒ     | âœ”               |
| Adds Border / Grid    | âŒ     | âœ”               |
| Reusable              | âœ”     | âœ”               |
| Safe to use           | âœ”     | âš                |
| Easy to maintain      | âœ”     | âŒ               |
| Uses ContentPresenter | âŒ     | âœ”               |

Style is used to set and reuse control properties, while ControlTemplate is used to redefine the internal 
visual structure of a control. Style is preferred for most UI changes, and ControlTemplate is used only when 
the default structure is insufficient.

Note : 
Always try Style first.
Use ControlTemplate only if Style is not enough.

# Resource Directory 

A ResourceDictionary is a container for reusable resources, such as:

- Styles
- Brushes (colors)
- Templates
- Converters
- DataTemplates

ğŸ‘‰ It helps you organize, reuse, and maintain resources cleanly.

## Why ResourceDictionary is Needed

Without it, everything goes into:

App.xaml file 

Which becomes:

- Huge
- Hard to manage
- Difficult to reuse

ğŸ‘‰ ResourceDictionary lets you split resources into separate files.

## Where Can You Use ResourceDictionary?

| Level                        | Scope             |
| ---------------------------- | ----------------- |
| Control.Resources            | Only that control |
| Window/UserControl.Resources | That window       |
| Application.Resources        | Entire app        |

## Basic ResourceDictionary File
ğŸ”¹ Create a ResourceDictionary

- Add New Item
- Select Resource Dictionary
- Name it Colors.xaml

Colors.xaml

<ResourceDictionary
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <SolidColorBrush x:Key="PrimaryBrush" Color="#2196F3"/>
    <SolidColorBrush x:Key="DangerBrush" Color="Red"/>

</ResourceDictionary>

## Using ResourceDictionary in App.xaml (MOST COMMON)

<Application.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <ResourceDictionary Source="Resources/Colors.xaml"/>
        </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
</Application.Resources>

## Window-Level ResourceDictionary

<Window.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <ResourceDictionary Source="ButtonStyles.xaml"/>
        </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
</Window.Resources>

âœ” Used only in that window

## MergedDictionaries (IMPORTANT)

You can merge multiple dictionaries:

<ResourceDictionary.MergedDictionaries>
    <ResourceDictionary Source="Resources/Colors.xaml"/>
    <ResourceDictionary Source="Resources/ButtonStyles.xaml"/>
    <ResourceDictionary Source="Resources/TextStyles.xaml"/>
</ResourceDictionary.MergedDictionaries>

## Best Practices (REAL PROJECTS)

âœ” Separate dictionaries by purpose
âœ” Keep App.xaml small
âœ” Use meaningful keys
âœ” Avoid duplicate keys
âœ” Use DynamicResource for themes
âœ” Prefer BasedOn for style reuse

## Common Mistakes

âŒ Putting everything in App.xaml
âŒ Forgetting to merge dictionary
âŒ Duplicate resource keys
âŒ Using ControlTemplate everywhere


