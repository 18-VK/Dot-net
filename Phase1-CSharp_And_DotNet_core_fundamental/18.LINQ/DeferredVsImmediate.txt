Deferred Execution
--------------------
Means the query is defined, but not executed immediately.
Execution happens only when you iterate (e.g., foreach, .ToList(), .Count(), etc.).
Each time you iterate, the query re-executes on the current data source.
Deferred queries are lazy â€” they wait until you actually need the result.

ğŸ§  Think: â€œLINQ query is just a plan, not an action, until I loop over it.â€

âš¡ Immediate Execution

The query is executed as soon as it is defined.
The results are stored in memory (e.g., a List, array, or scalar value).
Further changes in the data source donâ€™t affect the stored results.

ğŸ§  Think: â€œRun it now and store the result.â€

ğŸ§ª 2ï¸âƒ£ Examples
ğŸ•“ Deferred Execution Example
var numbers = new List<int> { 1, 2, 3, 4 };

// Query definition (not executed yet)
var query = numbers.Where(n => n > 2);

// Modify the source BEFORE iterating
numbers.Add(5);

// Now execution happens during iteration
foreach (var n in query)
{
    Console.WriteLine(n);
}

Output:

3
4
5

âœ… Because the query executes after adding 5, the new element is included.

âš¡ Immediate Execution Example
var numbers = new List<int> { 1, 2, 3, 4 };

// Query executed immediately by ToList()
var result = numbers.Where(n => n > 2).ToList();

// Modify the source
numbers.Add(5);

// Iterating over the result
foreach (var n in result)
{
    Console.WriteLine(n);
}


Output:

3
4


âœ… Because ToList() executed the query immediately, it captured the results before 5 was added.

ğŸ§­ 3ï¸âƒ£ How to Trigger Immediate Execution

LINQ methods that force execution:

Materialization methods:

ToList(), ToArray(), ToDictionary(), ToLookup()
Aggregation methods:
Count(), Sum(), Average(), Min(), Max(), First(), FirstOrDefault(), Single(), Any(), etc.

Why It Matters
---------------
These execute right away and return a result.

| Aspect         | Deferred Execution                            | Immediate Execution               |
| -------------- | --------------------------------------------- | --------------------------------- |
| Performance    | Can be more efficient â€” runs only when needed | May be wasteful if results unused |
| Data freshness | Reflects latest data                          | Uses snapshot at query time       |
| Memory use     | Low (streamed as you iterate)                 | Higher (stores all results)       |


ToLookup()
------------
creates an immutable, one-to-many dictionary-like structure
that maps a key â†’ collection of values.

Itâ€™s like GroupBy(), but it immediately executes and returns an ILookup<TKey, TElement>.

ğŸ§  Think of it as:

Dictionary<TKey, List<TElement>>
that is read-only and auto-groups your data.

ğŸ“˜ Syntax
ILookup<TKey, TElement> lookup = collection.ToLookup(
    keySelector,
    elementSelector   // optional
);


keySelector â†’ defines how to group

elementSelector â†’ defines what to include in each group (optional)

ğŸ§ª Example 1 â€” Basic grouping
var lookup = products.ToLookup(p => p.Category);

foreach (var group in lookup)
{
    Console.WriteLine($"Category: {group.Key}");
    foreach (var item in group)
        Console.WriteLine($"  {item.Name}");
}
Similar to GroupBy(), but the result is already evaluated and can be reused multiple times efficiently.